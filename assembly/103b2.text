コメントを頂いたので、書き直しました。
コメント「後半のコードには問題があります。powerpc64le-linux-gnuの呼び出し規約では、int型の値を返すときはこれを64bit符号拡張したものが%r3に入っている必要がありますが、このコードでは上位32bitにはゴミが入っています。したがって呼び出し側がenlargeの上位32bitが正しいことを仮定している場合に問題が発生します。」

以下のプログラムを103b2.sとして保存する。

#enlargeをシンボルテーブルに追加し、103b.cから見えるようにする。
    .globl enlarge
#enlargeの開始位置。
enlarge:
    #xを31ビット右シフトすると、x>=0のときは%r4==0,x<0の時は%r4==-1となる。
    extsw %r3,%r3
    srdi %r4,%r3,31
    extsw %r4,%r4
    #%r3=%r3+%r4。x<0の時は-1される。
    add %r3,%r3,%r4
    #%r4=%r4+1。
    addi %r4,%r4,1
    #%r3=%r3+%r4。x>=0の時は、+1されるが、x<0の時は%r4==0なのでそのまま。
    add %r3,%r3,%r4
    #return;
    blr

extswで符号拡張をしました。

103b.c
#include<stdio.h>

int enlarge(int x);

int main(){
    long x;
    while(scanf("%ld",&x) != EOF){
    printf("%ld\n",enlarge(x));
    }
    return 0;
}

以下のテストケースを103b.testとして保存した。
10
100000
13456
567665
762
465
2
1
0
-1
-2
-3456
-67
-13465
-1354676543
-10000000
0


コンパイルして、実行。
gccp 103b2.s 103b.c -o 103 -static -O2
./103

符号拡張する前は以下の出力だったが、
`--> ./103 < 103b.test                     
11
100001
13457
567666
763
466
3
2
1
17179869182
17179869181
17179865727
17179869116
17179855718
15825192640
17169869183

符号拡張したら以下の出力になってよかった。
`--> ./103 < 103b.test                     
11
100001
13457
567666
763
466
3
2
1
-2
-3
-3457
-68
-13466
-1354676544
-10000001
1

